\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{url}

\begin{document}

\title{Travail pratique \#3 - IFT-3065}
\author{Nicolas Lafond et Gevrai Jodoin-Tremblay}
\date{Dimanche 30 Avril 2017}
\maketitle

\section{Introduction}
Le but de ce travail était d'apprendre comment générer du code C à partir du 
langage fonctionnel Typer. Pour ce faire nous avons transformer la forme
intermédiaire elexp vers une nouvelle forme intermédiaire appelé cexp. Cette
forme nous était fourni avec le travail toutefois nous avons décider de faire
quelques changements sur cette forme afin de pouvoir représenter les fermetures
plus facilement dans notre code.

Il est a mentionner que nous avons été aidé par François Dufour et Vincent
Amyong qui sont aussi dans le cours. Cependant, cette aide ne fût que pour aider
à notre compréhension du travail, principalement pour la conversion de
fermetures et la capture de variables libres; l'idée d'utiliser les indexs
de Myers vient de François Dufour, mais l'implémentation est la nôtre.

\section{Conversion de fermetures}

Lors de la conversion de elexp, nous effectuons directement une conversion des
lambdas en fermetures. Ainsi, dès que l'on trouve un lambda dans l'arbre de
elexp, nous commençons par chercher toutes les variables libres de son corps.
\cite{closureconversion} Nous avons donc une liste ordonnée de variables, et
nous pouvons simplement repasser au travers du corps du lambda pour changer
toutes les variables se trouvant dans le tableau par l'indice dans ce tableau.
Aussi, puisque nous effectuons cette transformation selon \emph{depth first},
les variables internes qui auraient cachées les variables globales ont déjà
changé de noms lorsque vient le temps de capturer celles-ci. Ensuite, nous
faisons simplement \emph{hoister} ce lambda dans un tableau global (mutable,
pas très fonctionnel, nous savons) en lui donnant un nom unique. Finalement,
une fermeture \emph{Cexp.Closure} remplace ce lambda, celui ci prenant le nom
du lambda (soit le nom de la fonction qui sera généré en C) qu'il ferme ainsi
que le tableau des variables libres.

\section{Génération de code C}
Puisque notre préoccupation principale étant de générer du code C qui compile
sous GCC de la manière la plus simple possible, nous ne nous somme pas souciés
de la lisibilité du code généré. Ainsi le code C généré ne resemble pas à du
code C qui aurait été écrit par un humain.

\subsection{Type des données primitives}
Puisque les expressions cexp n'ont aucunes informations sur les types des 
expressions(étant donné qu'ils ont été effacés pendant la phase de 
transformation de lexp vers elexp) alors nous avions besoins d'un type
générique pour les déclarations dans le code C. Nous avons d'abord pensé à
utiliser des pointeurs génériques de type void* puis après avoir discuté avec
plusieurs autres étudiants du cours nous avons conclue qu'une représentation
des types par une type unions serait plus appropriée. Ce type union contient
chacun des types primitifs de Typer soit: les entiers, les nombres à virgules
flottants, les booléens, les chaînes de caractères et les fermetures(pour les
fonctions). Une bonne chose est que nous pouvions assumer qu'il n'y a pas
d'erreurs de typage dans les expressions elexp que nous reçevions donc nous
n'avions pas à nous préoccuper de vérifier que les expressions sont bien
typé dans le code C généré.

\subsection{Librairie de runtime\_support}
En plus de la représentation des types primitifs nous avons également créer
une infrastructure en C pour gérer l'environnement d'exécution du programme.
Nous l'avons implémenté avec une liste chaînée pour la simplicité.

\subsection{Représentation des datatypes}

\begin{thebibliography}{9}

\bibitem{realworldocaml}
	Yaron Minsky, Anil Madhavapeddy and Jason Hickey,
	Real World OCaml,
	\url{http://realworldocaml.org},
	O'Reilly,
	2012.

\bibitem{ocaml}
	Learn OCaml
	\url{https://ocaml.org/learn/},

\bibitem{inria}
	Xavier Leroy et al.,
	OCaml Doc and user's manual,
	\url{http://caml.inria.fr/pub/docs/manual-ocaml},
	Institut National de Recherche en Informatique et en Automatique,
	2013.

\bibitem{closureconversion}
	Matt Might,
  Closure conversion: How to compile lambda
	\url{http://matt.might.net/articles/closure-conversion/},
  University of Utah.
   
\bibitem{modern compiler implementation in ML}
    Andrew W. Appel,
    1998.

\end{thebibliography}
\end{document}

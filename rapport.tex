\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{url}

\begin{document}

\title{Travail pratique \#3 - IFT-3065}
\author{Nicolas Lafond et Gevrai Jodoin-Tremblay}
\date{Dimanche 30 Avril 2017}
\maketitle

\section{Introduction}
Le but de ce travail était d'apprendre comment générer du code C à partir du 
langage fonctionnel Typer. Pour ce faire nous avons transformer la forme
intermédiaire elexp vers une nouvelle forme intermédiaire appelé cexp. Cette
forme nous était fourni avec le travail toutefois nous avons décider de faire
quelques changements sur cette forme afin de pouvoir représenter les fermetures
plus facilement dans notre code.
 
\section{Structure du programme}
Nous avons décidé de créer un nouveau module OCaml pour le compilateur vers C.
Nous avons ajouté la rêgle typerc dans le makefile du projet pour compiler
le compilateur vers C au lieu de l'interpréteur Typer. Le fichier compile.ml
reprend une bonne partie du code du fichier REPL.ml mais au lieu d'évaluer
les expressions ils les transforment en cexp puis génère le code C.

Il est a mentionner que nous avons été aidé par François Dufour et Vincent
Amyong qui sont aussi dans le cours. Cependant, cette aide ne fût que pour aider
à notre compréhension du travail, principalement pour la conversion de
fermetures et la capture de variables libres; l'idée d'utiliser les indexs
de Myers vient de François Dufour, mais l'implémentation est la nôtre.

\section{Conversion de fermetures}
Nous avons fait la conversion de fermetures tel que vu dans le cours dans le
passage de elexp vers cexp. Nous avons ajouter un type Closure dans cexp pour
représenter un constructeur de fermetures. Chaque définition de fonctions dans
le fichier source Typer est alors transformé en construction de fermetures
dans la fonction main du programme C généré.

Lors de la conversion de elexp, nous effectuons directement une conversion des
lambdas en fermetures. Ainsi, dès que l'on trouve un lambda dans l'arbre de
elexp, nous commençons par chercher toutes les variables libres de son corps.
\cite{closureconversion} Nous avons donc une liste ordonnée de variables, et
nous pouvons simplement repasser au travers du corps du lambda pour changer
toutes les variables se trouvant dans le tableau par l'indice dans ce tableau.
Aussi, puisque nous effectuons cette transformation selon \emph{depth first},
les variables internes qui auraient cachées les variables globales ont déjà
changé de noms lorsque vient le temps de capturer celles-ci. Ensuite, nous
faisons simplement \emph{hoister} ce lambda dans un tableau global (mutable,
pas très fonctionnel, nous savons) en lui donnant un nom unique. Finalement,
une fermeture \emph{Cexp.Closure} remplace ce lambda, celui ci prenant le nom
du lambda (soit le nom de la fonction qui sera généré en C) qu'il ferme ainsi
que le tableau des variables libres.

\section{Génération de code C}
Puisque notre préoccupation principale étant de générer du code C qui compile
sous GCC de la manière la plus simple possible, nous ne nous somme pas souciés
de la lisibilité du code généré. Ainsi le code C généré ne resemble pas à du
code C qui aurait été écrit par un humain. Le code C généré à la forme suivante:
l'inclusion de la librairie de \textit{runtime support}, déclaration de tous 
les fonctions et variables, définitions des fonctions(qui sont tous les
fonctions fermé que nous avons obtenues en faisant la conversion de fermetures
sur les fonctions du programme source),  et finalement la fonction principale
\textit{main} qui va construire tous les variables et fermetures et les mêtre
dans l'environnement.

\subsection{Type des données primitives}
Puisque les expressions cexp n'ont aucunes informations sur les types des 
expressions(étant donné qu'ils ont été effacés pendant la phase de 
transformation de lexp vers elexp) alors nous avions besoins d'un type
générique pour les déclarations dans le code C. Nous avons d'abord pensé à
utiliser des pointeurs génériques de type void* puis après avoir discuté avec
plusieurs autres étudiants du cours nous avons conclue qu'une représentation
des types par une type unions serait plus appropriée. Ce type union contient
chacun des types primitifs de Typer soit: les entiers, les nombres à virgules
flottants, les booléens, les chaînes de caractères et les fermetures(pour les
fonctions). Une bonne chose est que nous pouvions assumer qu'il n'y a pas
d'erreurs de typage dans les expressions elexp que nous reçevions donc nous
n'avions pas à nous préoccuper de vérifier que les expressions sont bien
typé dans le code C généré.

\subsection{Librairie de runtime\_support}
En plus de la représentation des types primitifs nous avons également créer
une infrastructure en C pour gérer l'environnement d'exécution du programme.
Nous l'avons implémenté avec une liste chaînée pour la simplicité. Nous avons
Également implémenté des fonctions pour construire tous les types primitifs.
Finalement nous avons implémenté des fonctions équivalentes aux fonctions
\textit{builtins} pour ensuite transformer des fonctions \textit{builtins}
de typer vers celle équivalentes en C.

\subsection{Représentation des datatypes}
Nous avons pensé à représenter les datatypes par des unions qualifié tel que
mentionné sur le site web officiel de OCaml, il s'agit de structures composé
d'un entier pour représenter le type du datatype et d'une union pour
représenter les valeurs du datatypes.

\begin{thebibliography}{9}

\bibitem{realworldocaml}
	Yaron Minsky, Anil Madhavapeddy and Jason Hickey,
	Real World OCaml,
	\url{http://realworldocaml.org},
	O'Reilly,
	2012.

\bibitem{ocaml}
	Learn OCaml
	\url{https://ocaml.org/learn/},

\bibitem{inria}
	Xavier Leroy et al.,
	OCaml Doc and user's manual,
	\url{http://caml.inria.fr/pub/docs/manual-ocaml},
	Institut National de Recherche en Informatique et en Automatique,
	2013.

\bibitem{closureconversion}
	Matt Might,
  Closure conversion: How to compile lambda
	\url{http://matt.might.net/articles/closure-conversion/},
  University of Utah.
   
\bibitem{modern compiler implementation in ML}
    Andrew W. Appel,
    modern compiler implementation in ML,
    1998.

\end{thebibliography}
\end{document}

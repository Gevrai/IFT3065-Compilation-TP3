\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{url}

\begin{document}

\title{Travail pratique \#3 - IFT-3065}
\author{Nicolas Lafond et Gevrai Jodoin-Tremblay}
\date{Dimanche 30 Avril 2017}
\maketitle

\section{Introduction}
Le but de ce travail était d'apprendre comment générer du code C à partir du 
langage fonctionnel Typer. Pour ce faire nous avons transformer la forme
intermédiaire elexp vers une nouvelle forme intermédiaire appelé cexp. Cette
forme nous était fourni avec le travail toutefois nous avons décider de faire
quelques changements sur cette forme afin de pouvoir représenter les fermetures
plus facilement dans notre code.

\section{Structure du programme}
\subsection{compile.ml}
Nous avons décidé de créer un nouveau module \emph{OCaml} pour le compilateur
vers \emph{C}.
Nous avons ajouté la règle \emph{typerc} dans le makefile du projet pour compiler
le compilateur vers \emph{C} au lieu de l'interpréteur \emph{Typer}. Le fichier
\emph{compile.ml}
reprend une partie du code du fichier \emph{REPL.ml} mais au lieu d'évaluer
les expressions ils les transforment en \emph{cexp} puis génère le code C. Ainsi,
à l'image des exécutables \emph{ocaml} vs \emph{ocamlc}, nous pouvons compiler
un programme \emph{typer} vers \emph{C} grâce à l'exécutable \emph{typerc}.
Aussi, bien que par défaut le fichier \emph{C} généré soit nommé \emph{a.c},
on peut changé celui-ci grâce aux arguments \emph{--output} ou \emph{-o}.

\subsection{cexp.ml}
Éffectue la transformation d'un \texttt{(vname*elexp) list list} vers un
\emph{cfile}, y compris le hoisting et la conversion de fermetures des lambdas.

\subsection{codify.ml}
Écriture du code \emph{C} correspondant à un \emph{cfile}. Pour s'assurer de ne
pas avoir de conflits entre les noms de variables et fonctions de \emph{Typer}
et celles de \emph{runtime\_support.c}, les variables \emph{Typer} sont toutes
préfixées d'un \emph{underscore} \texttt{\_} dans le code, contrairement au code
de \emph{runtime\_support.c}.


\section{Conversion de fermetures}
Nous avons fait la conversion de fermetures tel que vu dans le cours dans le
passage de elexp vers cexp. Nous avons ajouter un type Closure dans cexp pour
représenter un constructeur de fermetures. Chaque définition de fonctions dans
le fichier source Typer est alors transformé en construction de fermetures
dans la fonction main du programme C généré.


Lors de la conversion de elexp, nous effectuons directement une conversion des
lambdas en fermetures. Ainsi, dès que l'on trouve un lambda dans l'arbre de
elexp, nous commençons par chercher toutes les variables libres de son corps.
\cite{closureconversion} Nous avons donc une liste ordonnée de variables, et
nous pouvons simplement repasser au travers du corps du lambda pour changer
toutes les variables se trouvant dans le tableau par l'indice dans ce tableau.
Aussi, puisque nous effectuons cette transformation selon \emph{depth first},
les variables internes qui auraient cachées les variables globales ont déjà
changé de noms lorsque vient le temps de capturer celles-ci. Ensuite, nous
faisons simplement \emph{hoister} ce lambda dans un tableau global (mutable,
pas très fonctionnel, nous savons) en lui donnant un nom unique. Finalement,
une fermeture \emph{Cexp.Closure} remplace ce lambda, celui ci prenant le nom
du lambda (soit le nom de la fonction qui sera généré en C) qu'il ferme ainsi
que le tableau des variables libres.

\section{Génération de code C}
Puisque notre préoccupation principale étant de générer du code C qui compile
sous GCC de la manière la plus simple possible, nous ne nous somme pas souciés
de la lisibilité du code généré. Ainsi le code C généré ne resemble pas à du
code C qui aurait été écrit par un humain. Le code C généré à la forme suivante:
l'inclusion de la librairie de \textit{runtime\_support}, déclaration de tous 
les fonctions et variables, définitions des fonctions(qui sont tous les
fonctions fermé que nous avons obtenues en faisant la conversion de fermetures
sur les fonctions du programme source),  et finalement la fonction principale
\textit{main} qui va construire tous les variables et fermetures et les mêtre
dans l'environnement.

\subsection{Type des données primitives}
Puisque les expressions cexp n'ont aucunes informations sur les types des 
expressions(étant donné qu'ils ont été effacés pendant la phase de 
transformation de lexp vers elexp) alors nous avions besoins d'un type
générique pour les déclarations dans le code C. Nous avons d'abord pensé à
utiliser des pointeurs génériques de type void* puis après avoir discuté avec
plusieurs autres étudiants du cours nous avons conclue qu'une représentation
des types par une type unions serait plus appropriée. Ce type union contient
chacun des types primitifs de Typer soit: les entiers, les nombres à virgules
flottants, les booléens, les chaînes de caractères et les fermetures(pour les
fonctions). Une bonne chose est que nous pouvions assumer qu'il n'y a pas
d'erreurs de typage dans les expressions elexp que nous reçevions donc nous
n'avions pas à nous préoccuper de vérifier que les expressions sont bien
typé dans le code C généré.

\subsection{Librairie de runtime\_support}
En plus de la représentation des types primitifs nous avons également créé
une infrastructure en C pour gérer l'environnement d'exécution du programme.
Nous l'avons implémenté avec une liste chaînée pour la simplicité. Nous avons
Également implémenté des fonctions pour construire tous les types primitifs.
Finalement nous avons implémenté des fonctions équivalentes aux fonctions
\textit{builtins} pour ensuite transformer des fonctions \textit{builtins}
de typer vers celle équivalentes en C.

\subsection{Génération des let}
Nous avons cherché assez longtemps pour trouver une façon de représenter en
C une suite d'expressions dont la dernière seulement doit être retourné, pour
finalement trouver une extension de GCC permettant exactement ceci, soit les
\emph{compound statements}\cite{gnu_statexprs}. Cette extension est normalement
utilisé surtout
dans la définition de Macros, mais convient parfaitement à notre problème.
En effet, les variables déclarées à l'intérieur de cette expressions n'entrent
pas en conflits avec les variables externes, et le fait d'utiliser une
expression \emph{inline} facilite grandement la tâche de compilation. En effet,
l'imense avantage de cette forme est nous pouvons maintenant traiter les lets
comme n'importe qu'elle autre expression. Ainsi, tout ce que nous faisons, c'est
imprimer une suite de \texttt{(\{primtype 'letvar' = cexp ; (\{ ... ;
  'expression à retourner' \})...\})}. La dernière expression est ainsi comme
toute autre valeur.


\subsection{Représentation des datatypes}
Nous avons pensé à représenter les datatypes par des unions qualifié tel que
mentionné sur le site web officiel de OCaml, il s'agit de structures composé
d'un entier pour représenter le type du datatype et d'une union pour
représenter les valeurs du datatypes.

\section{Aide externe}
Il est a mentionner que nous avons été aidé par François Dufour et Vincent
Amyong qui sont aussi dans le cours. Cependant, cette aide ne fût que pour aider
à notre compréhension initiale du travail, principalement pour la conversion de
fermetures et la capture de variables libres; l'idée d'utiliser les indexs
de \emph{Myers} vient de François Dufour, mais l'implémentation est la nôtre.

Aussi, nous n'avions aucune piste pour l'implémentation des \texttt{Case} et nous
avons donc consulté le travail de Simon Bernier St-Pierre sur \emph{Github}
\cite{sbstp}. Nous sommes conscient que ceci n'est pas idéal, mais soyez par
contre assuré que cette consultation n'était que pour aider à notre
compréhension, sans plus.
 
\begin{thebibliography}{9}

\bibitem{realworldocaml}
	Yaron Minsky, Anil Madhavapeddy and Jason Hickey,
	Real World OCaml,
	\url{http://realworldocaml.org},
	O'Reilly,
	2012.

\bibitem{ocaml}
	Learn OCaml
	\url{https://ocaml.org/learn/},

\bibitem{inria}
	Xavier Leroy et al.,
	OCaml Doc and user's manual,
	\url{http://caml.inria.fr/pub/docs/manual-ocaml},
	Institut National de Recherche en Informatique et en Automatique,
	2013.

\bibitem{closureconversion}
	Matt Might,
  Closure conversion: How to compile lambda
	\url{http://matt.might.net/articles/closure-conversion/},
  University of Utah.
  
\bibitem{modern compiler implementation in ML}
  Andrew W. Appel,
  modern compiler implementation in ML,
  1998.

\bibitem{gnu_statexprs}
  GNU GCC Online documentation: Statements and Declarations in Expressions,
	\url{https://gcc.gnu.org/onlinedocs/gcc/Statements-Exprs.html}.

\bibitem{sbstp}
  Simon Bernier St-Pierre,
  Ift3065/tp3,
	\url{https://github.com/sbstp/ift3065},
  2017.
  

\end{thebibliography}
\end{document}
